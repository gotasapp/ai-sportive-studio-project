#!/usr/bin/env python3
"""
API FastAPI para Geração de Jerseys com DALL-E 3
Sistema baseado em prompts otimizados específicos para cada time.
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from openai import OpenAI
import requests
import base64
from io import BytesIO
from PIL import Image
import os
from dotenv import load_dotenv
from typing import Optional
from pathlib import Path

load_dotenv()

# --- Modelos de Dados ---
class ImageGenerationRequest(BaseModel):
    model_id: str
    player_name: str
    player_number: str
    quality: str = "standard"

class GenerationResponse(BaseModel):
    success: bool
    image_base64: Optional[str] = None
    cost_usd: Optional[float] = None
    error: Optional[str] = None

# --- Gerador Principal ---
class JerseyGenerator:
    def __init__(self):
        self.api_key = os.getenv('OPENAI_API_KEY')
        if not self.api_key:
            raise Exception("OPENAI_API_KEY não encontrada")
        self.client = OpenAI(api_key=self.api_key)
        self.setup_team_prompts()

    def setup_team_prompts(self):
        """Carrega prompts otimizados de arquivos de texto no diretório image_references."""
        self.team_prompts = {}
        # O diretório 'image_references' está um nível acima, na raiz da API.
        # Path(__file__).parent.parent se refere ao diretório 'api', então precisamos de mais um .parent
        # para chegar na raiz do projeto onde 'image_references' deve estar.
        # No entanto, a execução via uvicorn a partir da raiz fará com que o CWD seja a raiz.
        # Vamos usar um caminho relativo que funcione com a estrutura atual.
        # A api é executada a partir de 'api/' ou da raiz?
        # O arquivo está em 'api/jersey_api_dalle3.py'.
        # O endpoint antigo usava Path("image_references")
        # Vamos assumir que a CWD é 'api/'.
        
        # Correção: O Uvicorn é executado a partir da raiz do projeto, então o caminho relativo está correto.
        # No entanto, o endpoint antigo está dentro da API. Se este script for executado diretamente,
        # o Path(__file__).parent dará o diretório do script.
        
        # A melhor abordagem é construir o caminho a partir da localização do script.
        script_dir = Path(__file__).parent
        # O diretório `image_references` está no mesmo nível que o script.
        image_dir = script_dir / "image_references"

        if not image_dir.is_dir():
            print(f"AVISO: Diretório de referências de imagem não encontrado em {image_dir}")
            return

        for team_dir in image_dir.iterdir():
            if team_dir.is_dir():
                prompt_file = team_dir / "prompt.txt"
                if prompt_file.is_file():
                    try:
                        team_name = team_dir.name.lower()
                        self.team_prompts[team_name] = prompt_file.read_text(encoding="utf-8")
                        print(f"INFO: Carregado prompt para o time: {team_name}")
                    except Exception as e:
                        print(f"ERRO: Falha ao carregar prompt para {team_dir.name}: {e}")
                else:
                    print(f"AVISO: Arquivo 'prompt.txt' não encontrado para o time: {team_dir.name}")

    def _get_team_name_from_model_id(self, model_id: str) -> str:
        """Extrai o nome do time do model_id"""
        return model_id.split('_')[0].lower()

    def generate_image(self, request: ImageGenerationRequest) -> str:
        """Gera uma camisa usando prompt otimizado específico do time."""
        
        team_name = self._get_team_name_from_model_id(request.model_id)
        
        if team_name not in self.team_prompts:
            raise ValueError(f"Time '{team_name}' não tem prompt configurado")
        
        # Pega o template do prompt e substitui os placeholders
        prompt_template = self.team_prompts[team_name]
        final_prompt = prompt_template.format(
            PLAYER_NAME=request.player_name.upper(),
            PLAYER_NUMBER=request.player_number
        )
        
        print(f"INFO: Gerando {team_name} com prompt otimizado")
        print(f"INFO: Prompt: {final_prompt[:100]}...")
        
        # Geração da imagem
        generation_response = self.client.images.generate(
            model="dall-e-3",
            prompt=final_prompt,
            size="1024x1024",
            quality=request.quality,
            n=1
        )
        
        image_url = generation_response.data[0].url
        img_response = requests.get(image_url, timeout=60)
        
        if img_response.status_code == 200:
            image = Image.open(BytesIO(img_response.content))
            buffered = BytesIO()
            image.save(buffered, format="PNG")
            return base64.b64encode(buffered.getvalue()).decode()
        else:
            raise Exception(f"Erro ao baixar imagem do DALL-E 3: {img_response.status_code}")

# --- Configuração da API FastAPI ---
app = FastAPI(title="Jersey Generator API", version="2.0.0")

# Lista de domínios permitidos
origins = [
    "http://localhost",
    "http://localhost:3000",
    "https://jersey-generator-ai2-git-master-jeffnight15s-projects.vercel.app",
    "https://jersey-generator-ai2.vercel.app" # Adicionando o domínio principal também
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

generator = JerseyGenerator()

@app.get("/")
async def root():
    return {"status": "online", "service": "Jersey Generator API", "version": "2.0.0"}

@app.post("/generate", response_model=GenerationResponse)
async def generate_image_endpoint(request: ImageGenerationRequest):
    try:
        image_base64 = generator.generate_image(request)
        return GenerationResponse(
            success=True,
            image_base64=image_base64,
            cost_usd=0.045  # Custo estimado
        )
    except Exception as e:
        print(f"ERROR: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- Health Check Endpoint ---
@app.get("/health")
async def health_check():
    """Endpoint to check if the API is running."""
    return {"status": "ok"}

# --- Get Available Teams Endpoint ---
@app.get("/teams")
async def get_available_teams():
    """Retorna a lista de times com prompts configurados."""
    return sorted([team.replace("_", " ").title() for team in generator.team_prompts.keys()])

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000) 